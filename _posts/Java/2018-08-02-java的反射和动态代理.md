---
layout: post
title: java的反射和动态代理
toc: true
cover: /img/cover/4f25cb0a83efe4097168eee9ad24170e.jpg
tags: ['java']
---

# java的反射

[TOC]

通过调用反射api(java.lang.reflect)可以在java中运行时动态获取类的信息,调用类的方法.  

反射在很多框架中都有应用,spring框架通过反射来实现IOC.

## class对象

java在加载类时会将java类的属性,方法,父类,实现的接口,注解等信息放到class对象中,我们可以通过class对象实现对java对象修改;

获取class对象的三种方式:

+ 使用`类名.class` 例如: `Object.class`
+ 使用Class类的`forName`方法
+ 使用对象的`getClass`方式

## 方法

### 使用反射调用方法

在使用反射时,很多时候都会使用到方法的反射调用, 通过`Method`类的`invoke`方法实现.

Method类的invoke方法:

```java
 @CallerSensitive
    public Object invoke(Object obj, Object... args)
        throws IllegalAccessException, IllegalArgumentException,
           InvocationTargetException
    {
        if (!override) {
            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
                Class<?> caller = Reflection.getCallerClass();
                checkAccess(caller, clazz, obj, modifiers);
            }
        }
        MethodAccessor ma = methodAccessor;             // read volatile
        if (ma == null) {
            ma = acquireMethodAccessor();
        }
        return ma.invoke(obj, args);
    }
```



从代码可以看出,`invoke`方法在前面进行权限检查后, 将调用委托给 `MethodAccessor` 实现.

---

### `MethodAccessor` 接口

`MethodAccessor`的两个实现:

+ 委派实现 (`DelegatingMethodAccessorImpl`)
+ 本地实现(`NativeMethodAccessorImpl`)



**在调用反射的时候是用委派实现还是本地?** 

代码实例:

```java
public class TestMethodInvoke {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        Class kclass = Class.forName("Test");
        Method method = kclass.getMethod("target", int.class);
        method.invoke(null, 0);
    }
}
class Test {
    public static void target(int i) {
        new Exception("#" + i).printStackTrace();
    }
}
```

运行结果:

```
java.lang.Exception: #0
	at Test.target(TestMethodInvoke.java:18)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at TestMethodInvoke.main(TestMethodInvoke.java:10)
```

通过运行结果可以看出: **反射调用方法是通过委派的模式进行的**.

### 为什么反射调用不直接交给本地调用,而要加一层委派作为中间层 ?

修改上面的代码将反射方法调用执行20次,查看结果.

```java
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class TestMethodInvoke {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        Class kclass = Class.forName("Test");
        Method method = kclass.getMethod("target", int.class);
        for (int i = 0; i < 20; i++) {
            method.invoke(null, i);
        }
    }
}
class Test {
    public static void target(int i) {
        new Exception("#" + i).printStackTrace();
    }
}
```

**查看第15次和16次的结果:**

```
java.lang.Exception: #15
	at Test.target(TestMethodInvoke.java:16)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at TestMethodInvoke.main(TestMethodInvoke.java:9)
java.lang.Exception: #16
	at Test.target(TestMethodInvoke.java:16)
	at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at TestMethodInvoke.main(TestMethodInvoke.java:9)
```

通过结果可以看出,在第16次及以后的调用是通过`GeneratedMethodAccessor1.invoke` 方法实现的调用, 而不再使用 本地方法实现,而是使用动态实现` GeneratedMethodAccessor1`来调用. java的反射机制设定了一种动态生成字节码,直接使用 invoke指令调用目标方法, **使用委派来实现是微利能跟在本地实现和东来实现中切换.**



