---
layout: post
title: java的网络
toc: true
cover: /img/cover/why-is-binary.png
tags: ['java','网络']
category: Java
---

# java的网络

## BIO

最开始的java中提供BIO支持,通过Socket类来实现.

- java ServerSocket 实例:
``` java
    ServerSocket serverSocket = new ServerSocket(8060);
    serverSocket.accept();
```

使用 new 一个ServerSocket 传入端口号来开启一个服务端, 使用 `accept`方法来阻塞线程,  监听网络请求. 

当有一个请求过来时,accept方法会返回  一个`Socket`对象, 通过这个`socket`对象和客户端进行通信.

  ```java
		Socket socket = serverSocket.accept();
  ```

- 读取客户端数据

  在接受到客户端请求后, 通过`socket`的`getInputStream`方法获取`inputStream`对象来读取客户端的数据.

- 向客户端写入数据

  通过socket的`getOutputSteam`获取`outputStream`对象来向客户端写入数据

### 读取写入数据实例:

- 服务端:

  ```java
  public class TestBIOServer {
    public static void main(String[] args) {
        try {
            ServerSocket serverSocket = new ServerSocket(9080);
            while (true) {
                Socket accept = serverSocket.accept();
                final InputStream inputStream = accept.getInputStream();
                final BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
                final OutputStream outputStream = accept.getOutputStream();
  
                new ReadDataThread("读取数据线程", bufferedReader).start();
                new WriteDataThread("写入数据线程", outputStream, accept).start();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
  }
  class ReadDataThread extends Thread {
    private BufferedReader bufferedReader;
    public ReadDataThread(String name, BufferedReader bufferedReader) {
        super(name);
        this.bufferedReader = bufferedReader;
    }
    @Override
    public void run() {
        logout(Thread.currentThread() + "启动");
        try {
            String line = null;
            while ((line = bufferedReader.readLine()) != null) {
                logout(line);
            }
            logout("服务端读取数据完成");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
  }
  class WriteDataThread extends Thread {
    private final Socket socket;
    private OutputStream outputStream;
  
    public WriteDataThread(String name, OutputStream outputStream, Socket accept) {
        super(name);
        this.outputStream = outputStream;
        this.socket = accept;
    }
    @Override
    public void run() {
        logout(Thread.currentThread() + "启动");
        try {
            logout("server 开始向 client写入数据 ");
            outputStream.write(("server -> client : 你好 client端 \n".getBytes()));
            logout("休息5秒");
            Thread.sleep(5000);
            outputStream.write(("server -> client : 嗨  client端 \n".getBytes()));
            logout("server 写入数据完成");
            socket.shutdownOutput();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
  }
  ```
```
- 客户端:

```
public static void logout(String s) {
        System.out.println("[ " + LocalTime.now() + "] \t" + s);
    }
    public static void main(String[] agrs) {
        try {
            final Socket socket = new Socket("localhost", 9080);
            final InputStream inputStream = socket.getInputStream();
            final BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
            final OutputStream outputStream = socket.getOutputStream();

            new Thread("读取数据线程") {
                @Override
                public void run() {
                    logout("client读取数据线程启动");
                    try {
                        String line = null;
                        while ((line = bufferedReader.readLine()) != null) {
                            logout(line);
                        }
                        logout("client 端读取数据完成");
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
    
                }
            }.start();
            new Thread("写入数据线程") {
                @Override
                public void run() {
                    logout("client 写入数据线程启动");
                    try {
                        logout("client 开始向 Server写入数据");
                        outputStream.write(("client -> server : hello server \n".getBytes()));
                        logout("休息10秒");
                        Thread.sleep(10000);
                        outputStream.write(("client -> server : hi  server \n ".getBytes()));
                        logout("client 写入数据完成");
                        socket.shutdownOutput();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
    
                }
            }.start();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
```

输出结果: 
  - 服务端:
  
```
[ 16:39:21.399] 	Thread[写入数据线程 -> from Main,5,main]启动
[ 16:39:21.400] 	server 开始向 client写入数据 
[ 16:39:21.401] 	休息5秒
[ 16:39:21.401] 	Thread[读取数据线程,5,main]启动
[ 16:39:21.448] 	client -> server : hello server 
[ 16:39:26.404] 	server 写入数据完成
[ 16:39:31.451] 	client -> server : hi  server 
[ 16:39:31.452] 	 
[ 16:39:31.453] 	服务端读取数据完成
```

- 客户端

```
[ 16:39:21.440] 	client 写入数据线程启动
[ 16:39:21.441] 	client读取数据线程启动
[ 16:39:21.441] 	client 开始向 Server写入数据
[ 16:39:21.445] 	server -> client : 你好 client端 
[ 16:39:21.446] 	休息10秒
[ 16:39:26.404] 	server -> client : 嗨  client端 
[ 16:39:26.405] 	client 端读取数据完成
[ 16:39:31.451] 	client 写入数据完成
```

使用socket进行网络通讯时,服务端accept方法是阻塞的,当来了一个请求后accept方法会返回一个socket对象,然后执行后面的代码.所以需要一个线程去处理这个请求,在处理请求时读取数据(`line = bufferedReader.readLine()`)时,会发生阻塞, 直到有数据来才会执行. 

**使用BIO的缺点:** 

一个客户端请求过来一个线程进行处理,处理完成线程才能释放,如果请求数量过多时,会占用大量的服务器线程.

## NIO
从jdk1.4开始java引入NIO实现网络通讯,在通讯过程中 使用双向通道(channel)进行数据传送,而不是单向的流, 在通道上注册各种事件,当系检查到该通道的事件时,通知线程进行操作.

- NIO 服务端实现步骤: 

创建`selector`, selector能接受到网络请求中的各种事件,然后返回各种事件的key.然后通过判断key对网络请求做出各种操作.

NIO 服务端:

```

package test;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.util.Iterator;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;

import static test.TestBIOClient.logout;

public class TestNIOServer {

    private static final ConcurrentHashMap<String, SocketChannel> clientMap = new ConcurrentHashMap();

    private Selector selector;

    public static void main(String[] args) {
        new TestNIOServer().openServer();
    }
    private void openServer() {
        //创建selector
        try {
            selector = Selector.open();
            //创建ServerSocketChnal
            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
            //设置服务端通道为非阻塞
            serverSocketChannel.configureBlocking(false);
            //绑定端口
            serverSocketChannel.bind(new InetSocketAddress(7080));
            //给服务端注册 accept事件
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            while (true) {
                //select 方法会阻塞 直到有selector有事件
                selector.select();
                Set<SelectionKey> keys = selector.selectedKeys();
                Iterator<SelectionKey> keyIterator;
                keyIterator = keys.iterator();
                while (keyIterator.hasNext()) {
                    SelectionKey key = keyIterator.next();
                    //获取key后要移除掉
                    keyIterator.remove();

                    //处理事件
                    handlerKey(key);
                }
            }

        } catch (IOException e) {
            logout(e);
            e.printStackTrace();
        }


    }

    private void handlerKey(SelectionKey key) throws IOException {
        try {

            //服务端接受请求
            if (key.isAcceptable()) {
                logout("isAcceptable");
                ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();
                //服务端接受客户端请求后创建和客户端连接的通道
                SocketChannel accept = serverSocketChannel.accept();
                //设置通道为不阻塞
                accept.configureBlocking(false);

                //给和客户端连接的通过注册 读取 事件
                accept.register(selector, SelectionKey.OP_READ);
                //将客户端连接缓存起来
                String clientName = UUID.randomUUID().toString();
                ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
                byteBuffer.put(("your name is " + clientName).getBytes());
                byteBuffer.flip();
                accept.write(byteBuffer);


            } else if (key.isReadable()) {

                logout("isReadable");


                //accept 读取客户端的内容
                SocketChannel channel = (SocketChannel) key.channel();
                logout("remote address :" + channel.getRemoteAddress());

                ByteBuffer byteBuffer = ByteBuffer.allocate(1024);

                int readLen = channel.read(byteBuffer);

                //如果已经不能读取数据了,关闭通道
                if (readLen == -1) {
                    channel.close();
                    return;
                }

                StringBuffer stringBuffer = new StringBuffer();
                while (readLen > 0) {
                    logout("读取长度:" + readLen);
                    stringBuffer.append(new String(byteBuffer.array()));
                    byteBuffer.clear();
                    readLen = channel.read(byteBuffer);
                }

                logout(stringBuffer);
                byteBuffer.clear();
            }

        } catch (Exception e) {
            e.printStackTrace();
        }

    }


}
```

- NIO 客户端:

```
 package test;


import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;

import static test.TestBIOClient.logout;

public class TestNIOClient {

    private Selector selector;


    public static void main(String[] args) {
        new TestNIOClient().connect();
    }

    private void connect() {
        //创建通道
        try {
            //初始化 selector
            selector = Selector.open();
            for (int i = 0; i < 1000; i++) {
                SocketChannel channel = SocketChannel.open();
                channel.configureBlocking(false);
                channel.connect(new InetSocketAddress("localhost", 7080));

                //注册客户端通道
                channel.register(selector, SelectionKey.OP_CONNECT);

                logout("channel register OP_CONNECT : " + i);
            }

            while (true) {
                selector.select();
                Set<SelectionKey> keys = selector.selectedKeys();
                Iterator<SelectionKey> keyIterator = keys.iterator();
                while (keyIterator.hasNext()) {
                    SelectionKey key = keyIterator.next();
                    keyIterator.remove();
                    handlerKey(key);
                }
            }

        } catch (IOException e) {
            logout(e);
            e.printStackTrace();
        }


    }

    private void handlerKey(SelectionKey key) throws IOException {
        SocketChannel _channel = (SocketChannel) key.channel();
        try {
            if (key.isConnectable()) {
                logout("client isConnectable");

                //完成连接
                SocketChannel channel = (SocketChannel) key.channel();
                logout("client finishConnect");
                channel.finishConnect();
                logout("localhost address :" + channel.getLocalAddress());

                ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
                byteBuffer.put("hello server this client ".getBytes());
                byteBuffer.flip();
                channel.write(byteBuffer);

                //注册读取事件
                channel.register(selector, SelectionKey.OP_READ);
            } else if (key.isReadable()) {
                //读取服务端发送的数据
                SocketChannel channel = (SocketChannel) key.channel();

                ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
                int read = channel.read(byteBuffer);

                if (read == -1) { //等于-1代表不可读状态
                    channel.close();
                    return;
                }

                StringBuffer stringBuffer = new StringBuffer();
                while (read > 0) {
                    stringBuffer.append(new String(byteBuffer.array()));
                    byteBuffer.clear();
                    read = channel.read(byteBuffer);
                }

                logout(stringBuffer);
            }
        } catch (Exception e) {
            e.printStackTrace();
            logout("exception channel : " + _channel.getLocalAddress());

        }
    }


}
```

NIO 在服务端和客户端各自创建一个 `selector` 对象管理各种事件的处理, 在无限循环中 selector 执行 select方法, 这个方法没有事件时会阻塞,当它注册的channel有事件时会执行select方法后面的内容.

客户端过来请求时服务端创建一个 channel 和对应,然后将 这个 channel 注册到selector上, 当客户端有数据过来时, selector 会处理事件.




