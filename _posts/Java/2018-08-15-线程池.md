---
layout: post
title: 线程池
toc: true
cover: /img/cover/why-is-binary.png
tags: ['java','并发']
category: Java
---

## 简介

线程池可以看做一组线程的集合,使用线程池可以服用线程,避免了重复创建和销毁线程带来的开销.

## 继承体系

基础关系图:

![image-20180823213719074](../../../assets/img/2018/08/ThreadExtent.png)

从继承体系中可以看出,最顶层的接口为`Executor`,在Executor中只定义了一个方法.

各层定义的方法:

+ `Executor` 
  + `execute`  最基本的执行方法
+ `ExecutorService` 
  + `shutdown`
  + `submit`
  + `invokeAll`
  + `invokeAny`
+ `ScheduledExecutorService`

## 线程池的使用

### `ThreadPoolExecutor`的构造参数:

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    ... 
}
```

+ corePoolSize  核心线程数
+ maximumPoolSize 线程池能维护的最大线程
+ keepAliveTime 空值线程最大保利时间 
+ workQueue     任务队列.
+ threadFactory  产生线程的工厂
+ handler 拒绝策略. 线程池和任务队列都饱和时, 使用拒绝策略处理新过来的任务. 默认是AbortPolicy 直接抛出异常.

### 创建线程的规则

|      | 条件                                                         | 动作         |
| ---- | ------------------------------------------------------------ | ------------ |
| 1    | 线程数 < corePoolSize                                        | 创建新的线程 |
| 2    | 线程数 >= corePoolSize 并且 workQueue没有满                  | 缓存新的任务 |
| 3    | corePoolSize ≤  线程数 ＜ maximumPoolSize 并且 workQueue 未满 | 创建新的线程 |
| 4    | 线程数 >=  maximumPoolSize 并且 workQueue 未满               | 缓存新的任务 |
| 5    | 线程数 >=  maximumPoolSize 并且 workQueue 已满               | 使用拒绝策略 |

### 线程回收

当任务队列没有任务时,并且线程池中的线程数大于 corePoolSize数量时,会进行回收闲置线程操作.

线程回收条件:

+ 线程池的线程数 > corePoolSize 
+ 闲置线程空闲时间 超过 keepAliveTime
+ 当线程池的的`allowCoreThreadTimeOut`属性设置为true时,corePoolSize内的闲置线程也会被回收

### 排队策略

当任务数量 大于corePoolSize , 并且 workQueue 未满时, 则缓存新的任务.使用什么类型的容器容器缓存新任务? 

**4中队列类型以及实现类:**

|        实现类         | 类型     | 说明                                                         |
| :-------------------: | -------- | ------------------------------------------------------------ |
|    SychronousQueue    | 同步队列 | 队列不存储元素,每插入一个必须等待另一个线程调用移除操作,否则插入操作一直阻塞 |
|  ArrayBlockingQueue   | 有界队列 | 基于数组的阻塞队列, 按照 FIFO原则对元素进行排序              |
| LinkedBlockeingQueue  | 无界队列 | 基于链表的阻塞队列, 按照 FIFO原则对元素进行排序              |
| PriorityBlockingQueue | 优先队列 | 具有优先级的阻塞队列                                         |

### 拒绝策略

在创建线程池的参数` RejectedExecutionHandler handler` 是表示选用那种拒绝策略. 在线程数量大于 maximumPoolSize时,而且workQueue已满是, 线程池使用拒绝策略来处理新添加的任务.

**java线程池提供的四种拒绝策略:**

| 实现类           | 说明                                          |
| ---------------- | --------------------------------------------- |
| AbortPolicy      | 丢弃任务,抛出`RejectedExecutionException`异常 |
| DiscardPolicy    | 不做任何操作,抛弃新任务                       |
| DiscardOldPolicy | 丢弃队列首的元素, 执行新任务                  |
| CallerRunsPolicy | 由调用线程执行新任务                          |

线程池默认的拒绝策略是`AbortPolicy`可以调用 `setRejectedExecutionHandler`方法设置拒绝策略. 

## 操作线程

### 线程的创建与复用

线程池对象创建线程是通过 线程的工厂类执行newThread方法实现 

```java
Worker(Runnable firstTask) {
    setState(-1); // inhibit interrupts until runWorker
    this.firstTask = firstTask;
    //调用工厂类创建线程
    this.thread = getThreadFactory().newThread(this);
}
```

线程池的线程 执行任务, 是通过不断的从 队列中获取任务执行.

**worker的run方法** 

```
public void run() {
    runWorker(this);
}
```

**runWorker方法:**

```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // allow interrupts
    boolean completedAbruptly = true;
    try {
    	//循环的获取任务执行
        while (task != null || (task = getTask()) != null) {
            w.lock();
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                wt.interrupt();
            try {
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                	//执行任务
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        //线程退出后的处理
        processWorkerExit(w, completedAbruptly);
    }
}
```

### 提交任务的流程

![线程池提交任务流程](../../Desktop/线程池提交任务流程.png)

**添加任务执行线程池对象的`execute`方法:**

```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    int c = ctl.get();
    //如果线程数小于核心线程数 创建新的线程
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    // 如果缓存队列已满 offer 返回false,否则返回true
    // 缓存任务  
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) && remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            //添加非核心线程
            addWorker(null, false);
    }
    //如果线程数 < 最大线程数 添加线程(addWorker中检查) 否则使用拒绝策略
    else if (!addWorker(command, false))
        reject(command);
}
```

**线程池对象的addWorker方法:**

```java
private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        if (rs >= SHUTDOWN &&
            ! (rs == SHUTDOWN &&
               firstTask == null &&
               ! workQueue.isEmpty()))
            return false;

        for (;;) {
            int wc = workerCountOf(c);
            if (wc >= CAPACITY ||
            	//当前线程数 和 核心线程数 或者最大线程数比较
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            if (compareAndIncrementWorkerCount(c))
                break retry;
            c = ctl.get();  // Re-read ctl
            if (runStateOf(c) != rs)
                continue retry;
            // else CAS failed due to workerCount change; retry inner loop
        }
    }

    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        //创建Worker对象
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                int rs = runStateOf(ctl.get());

                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    //将worker对象添加到woker的集合中 
                    workers.add(w);
                    int s = workers.size();
                    //修改largestPoolSize属性
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            if (workerAdded) {
                //启动线程
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```

### 几种常见的线程池

一般情况下不会使用线程池类`ThreadPoolExecutor` 创建对象, 而是通过线程池工具类 `Executors` 构造线程池.  

**Executors可以构造的五种不同的线程池:**

|                   方法                   |                             说明                             |
| :--------------------------------------: | :----------------------------------------------------------: |
|     newFixedThreadPool(int nThreads)     |   构造包含固定线程数的线程池, 默认情况下空闲线程不会被回收   |
|       newCachedThreadThreadPool()        | 构造数量不定的线程池, 线程数随着任务数变动  <br />,空闲线程存活时间超过60秒就会被回收 |
|        newSingleThreadExecutor()         |                    构建线程数为1的线程池.                    |
| newScheduledThreadPool(int corePoolSize) |    构建核心线程数为 corePoolSize，可执行定时任务的线程池     |
|    newSingleThreadScheduledExecutor()    |               等价于 newScheduledThreadPool(1)               |

 

引用: [Java-线程池原理分析](http://www.coolblog.xyz/2018/04/17/Java-线程池原理分析/)





