---
layout: post
title: springMVC_1 Servlet启动
toc: true
cover: media/image-20180722003052030.png
tags: ['spring','java']
category: Java
---

## spring MVC 的启动

### 1. HttpServletBean的init方法

spring MVC 通过DispatcherServlet 和 web容器结合,实现web的功能.

**DispatcherServlet继承体系:**

![image-20180907151313101](../../../../../assets/img/2018/09/image-20180907151313101.png)



在web.xml中配置 后, 在web容器启动后会执行Servlet的`init`方法类初始化Servlet,`DispatcherServlet`的`init`方法在父类`HttpServletBean`中.    

**init方法代码:**

```java
/**
 * Map config parameters onto bean properties of this servlet, and
 * invoke subclass initialization.
 * @throws ServletException if bean properties are invalid (or required
 * properties are missing), or if subclass initialization fails.
 */
@Override
public final void init() throws ServletException {
   if (logger.isDebugEnabled()) {
      logger.debug("Initializing servlet '" + getServletName() + "'");
   }

   // Set bean properties from init parameters.
   //将init-param的参数封装到到PropertyValues 中
   PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);
   if (!pvs.isEmpty()) {
      try {
         //将当期Servlet类封装成一个BeanWrapper, 从而能使用spring的方式 将 init-param中的参数注入
         BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);
         ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());
         //给BeanWarpper 注册自定义的PropertyEditor,遇到 Resource类型属性时 将使用 ResourceEditor 进行解析
         bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));
         //留给子类覆盖的处理BeanWrapper方法
         initBeanWrapper(bw);
         //将从init-param解析的属性注入BeanWrapper
         bw.setPropertyValues(pvs, true);
      }
      catch (BeansException ex) {
         if (logger.isErrorEnabled()) {
            logger.error("Failed to set bean properties on servlet '" + getServletName() + "'", ex);
         }
         throw ex;
      }
   }

   // Let subclasses do whatever initialization they like.
   initServletBean();

   if (logger.isDebugEnabled()) {
      logger.debug("Servlet '" + getServletName() + "' configured successfully");
   }
}
```

init方法执行的步骤:

1. 解析在web.xml文件中配置的init-params参数,获得PropertyValues对象

2. 将DispatcherServlet对象封装到BeanWrapper

3. 给BeanWrapper对象注册Resource类的属性编辑器ResourceEditor

4. 将获得到的PropertyValues属性设置到BeanWrapper对象中去

5. 执行由子类实现的`initServletBean` 方法进行 Servlet初始化,创建Servlet的WebApplicationContext 

### 2. webApplicationContext的初始化

`initServletBean`方法在子类`FrameworkServlet`中实现. 

```java
/**
 * Overridden method of {@link HttpServletBean}, invoked after any bean properties
 * have been set. Creates this servlet's WebApplicationContext.
 */
@Override
protected final void initServletBean() throws ServletException {
   getServletContext().log("Initializing Spring FrameworkServlet '" + getServletName() + "'");
   if (this.logger.isInfoEnabled()) {
      this.logger.info("FrameworkServlet '" + getServletName() + "': initialization started");
   }
   long startTime = System.currentTimeMillis();

   try {
      //初始化WebApplicationContext
      this.webApplicationContext = initWebApplicationContext();
      initFrameworkServlet();
   }
   catch (ServletException ex) {
      this.logger.error("Context initialization failed", ex);
      throw ex;
   }
   catch (RuntimeException ex) {
      this.logger.error("Context initialization failed", ex);
      throw ex;
   }

   if (this.logger.isInfoEnabled()) {
      long elapsedTime = System.currentTimeMillis() - startTime;
      this.logger.info("FrameworkServlet '" + getServletName() + "': initialization completed in " +
            elapsedTime + " ms");
   }
}
```

在`initServletBean` 方法中 调用`initWebApplicationContext`方法来创建或者刷新 webApplicationContext实例,并对servlet用到的组件进行初始化. 

**`initServletBean`方法:**

```java
protected WebApplicationContext initWebApplicationContext() {
    //根据当前servlet的name在ServletContext中找WebApplicationContext.
    WebApplicationContext rootContext =
            WebApplicationContextUtils.getWebApplicationContext(getServletContext());
    WebApplicationContext wac = null;

    if (this.webApplicationContext != null) {
        // A context instance was injected at construction time -> use it
        //使用构造函数中设置的context实例
        wac = this.webApplicationContext;
        if (wac instanceof ConfigurableWebApplicationContext) {
            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;
            if (!cwac.isActive()) {
                // The context has not yet been refreshed -> provide services such as
                // setting the parent context, setting the application context id, etc
                if (cwac.getParent() == null) {
                    // The context instance was injected without an explicit parent -> set
                    // the root application context (if any; may be null) as the parent
                    cwac.setParent(rootContext);
                }
                //刷新上下文环境
                configureAndRefreshWebApplicationContext(cwac);
            }
        }
    }
    if (wac == null) {
        // No context instance was injected at construction time -> see if one
        // has been registered in the servlet context. If one exists, it is assumed
        // that the parent context (if any) has already been set and that the
        // user has performed any initialization such as setting the context id
        //根据contextAttribute属性从ServletContext中获取WebApplicationContext
        wac = findWebApplicationContext();
    }
    if (wac == null) {
        // No context instance is defined for this servlet -> create a local one
        //创建webApplicationContext
        wac = createWebApplicationContext(rootContext);
    }

    if (!this.refreshEventReceived) {
        // Either the context is not a ConfigurableApplicationContext with refresh
        // support or the context injected at construction time had already been
        // refreshed -> trigger initial onRefresh manually here.
        //刷新webApplicationContext 交给子类实现,
        onRefresh(wac);
    }

    //将context设置到ServletContext中
    if (this.publishContext) {
        // Publish the context as a servlet context attribute.
        String attrName = getServletContextAttributeName();
        getServletContext().setAttribute(attrName, wac);
        if (this.logger.isDebugEnabled()) {
            this.logger.debug("Published WebApplicationContext of servlet '" + getServletName() +
                    "' as ServletContext attribute with name [" + attrName + "]");
        }
    }

    return wac;
}
```
**`initServletBean` 步骤:**

1. 获取或者创建WebApplicationContext
2. 配置`WebApplicationContext`,调用`refresh`方法刷新.
3. 调用子类实现的`onRefresh`方法对`WebApplicationContext`进行刷新

`onRefresh` 被子类`DispatcherServlet`覆盖, 所以WebApplication创建好,调用Dispathcer的`onRefresh`对其进行最后的处理. 

### 3. 初始化Web功能的相关组件

**DispatcherServlet的onRefresh方法:**

```
@Override
protected void onRefresh(ApplicationContext context) {
   initStrategies(context);
}
```

**initStrategies 方法:**

```java
/**
 * Initialize the strategy objects that this servlet uses.
 * <p>May be overridden in subclasses in order to initialize further strategy objects.
 */
protected void initStrategies(ApplicationContext context) {
   //初始化MultipartResolver
   initMultipartResolver(context);
   //初始化 LocalResolver
   initLocaleResolver(context);
   //初始化ThemeResolver
   initThemeResolver(context);
   // 初始化 HanddlerMappings
   initHandlerMappings(context);
   //初始化 HandlerAdapters
   initHandlerAdapters(context);
   //初始化 ExceptionResolvers
   initHandlerExceptionResolvers(context);
   //初始化 RequestToViewNameTranslator
   initRequestToViewNameTranslator(context);
   //初始化 ViewResolvers
   initViewResolvers(context);
   //初始化 FlashMapManager
   initFlashMapManager(context);
}
```

### 4. HandlerMapping的初始化

handlerMapping 完成了将http请求和Contrller映射的功能, Servlet通过HanddlerMapping查找http请求对应的controller. HanddlerMapping. 

```java
/**
 * Initialize the HandlerMappings used by this class.
 * <p>If no HandlerMapping beans are defined in the BeanFactory for this namespace,
 * we default to BeanNameUrlHandlerMapping.
 */
private void initHandlerMappings(ApplicationContext context) {
   this.handlerMappings = null;
   //默认设置为true 从所有的容器中获取
   if (this.detectAllHandlerMappings) {
      //从当前容器以及,其父容器中获取
      // Find all HandlerMappings in the ApplicationContext, including ancestor contexts.
      Map<String, HandlerMapping> matchingBeans =
            BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false);
      if (!matchingBeans.isEmpty()) {
         this.handlerMappings = new ArrayList<HandlerMapping>(matchingBeans.values());
         // We keep HandlerMappings in sorted order.
         AnnotationAwareOrderComparator.sort(this.handlerMappings);
      }
   }
   else {
      try {
         HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);
         this.handlerMappings = Collections.singletonList(hm);
      }
      catch (NoSuchBeanDefinitionException ex) {
         // Ignore, we'll add a default HandlerMapping later.
      }
   }

   // Ensure we have at least one HandlerMapping, by registering
   // a default HandlerMapping if no other mappings are found.
   //如果从容器中没有获取到,则通过DispatcherServlet.properties 获取一个默认的HanddlerMapping
   if (this.handlerMappings == null) {
      this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);
      if (logger.isDebugEnabled()) {
         logger.debug("No HandlerMappings found in servlet '" + getServletName() + "': using default");
      }
   }
}
```

handlerMapping从BeanDefinition中获取映射关系, 其他的初始化过程和HanddlerMapping类似,都是通过IOC容器中读入配置. 

HanddlerMapping中只有一个方法`HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;`, 通过这个方法能通过`Request`来获取一个执行链,通过执行链来处理请求. 

`HandlerExecutionChain`的构造器:

```java
public HandlerExecutionChain(Object handler, HandlerInterceptor... interceptors) {
   if (handler instanceof HandlerExecutionChain) {
      HandlerExecutionChain originalChain = (HandlerExecutionChain) handler;
      this.handler = originalChain.getHandler();
      this.interceptorList = new ArrayList<HandlerInterceptor>();
      CollectionUtils.mergeArrayIntoCollection(originalChain.getInterceptors(), this.interceptorList);
      CollectionUtils.mergeArrayIntoCollection(interceptors, this.interceptorList);
   }
   else {
      this.handler = handler;
      this.interceptors = interceptors;
   }
}
```

`HandlerExecutionChain`中除了包含handler 还包含一个拦截器List的属性,通过设置拦截器对handler的功能进行增强.  

## HTTP请求的处理

### Servlet的Http请求处理

当有请求到服务器时,Servlet的入口是`service(ServletRequest req, ServletResponse res)`方法, 在HttpServlet中的此方法将参数转化和HTTP请求相关的参数,然后调用`service(HttpServletRequest req, HttpServletResponse resp)` 方法来处理逻辑,根据不同的请求跳转到不同的方法中, 例如 get请求跳转到doGet方法,post请求跳转到doPost请求,在FrameworkServlet中覆盖了这些方法,所以后面的逻辑都交给 FrameworkServlet 来处理.覆盖的这些方法都调用`processRequest`方法.  

```java
/**
 * Process this request, publishing an event regardless of the outcome.
 * <p>The actual event handling is performed by the abstract
 * {@link #doService} template method.
 */
protected final void processRequest(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {

    long startTime = System.currentTimeMillis();
    Throwable failureCause = null;

    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();
    LocaleContext localeContext = buildLocaleContext(request);

    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();
    ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);

    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor());

    //设置参数到ThreaLocal中
    initContextHolders(request, localeContext, requestAttributes);

    try {
        doService(request, response);
    } catch (ServletException ex) {
        failureCause = ex;
        throw ex;
    } catch (IOException ex) {
        failureCause = ex;
        throw ex;
    } catch (Throwable ex) {
        failureCause = ex;
        throw new NestedServletException("Request processing failed", ex);
    } finally {
        //将之前设置的属性从ThreadLocal中移除
        resetContextHolders(request, previousLocaleContext, previousAttributes);
        if (requestAttributes != null) {
            requestAttributes.requestCompleted();
        }

        if (logger.isDebugEnabled()) {
            if (failureCause != null) {
                this.logger.debug("Could not complete request", failureCause);
            } else {
                if (asyncManager.isConcurrentHandlingStarted()) {
                    logger.debug("Leaving response open for concurrent processing");
                } else {
                    this.logger.debug("Successfully completed request");
                }
            }
        }

        publishRequestHandledEvent(request, response, startTime, failureCause);
    }
}
```

processRequest 只是进行前置处理工作, 真正的处理逻辑在`doService`方法中. doService方法定义子类DispatcherServlet中. 

**DispatcherServlet 的 doService方法:**

```java
/**
 * Exposes the DispatcherServlet-specific request attributes and delegates to {@link #doDispatch}
 * for the actual dispatching.
 */
@Override
protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {
   if (logger.isDebugEnabled()) {
      String resumed = WebAsyncUtils.getAsyncManager(request).hasConcurrentResult() ? " resumed" : "";
      logger.debug("DispatcherServlet with name '" + getServletName() + "'" + resumed +
            " processing " + request.getMethod() + " request for [" + getRequestUri(request) + "]");
   }

   // Keep a snapshot of the request attributes in case of an include,
   // to be able to restore the original attributes after the include.
   //如果Request中包含javax.servlet.include.request_uri属性,保存处理请求参数的快照
   Map<String, Object> attributesSnapshot = null;
   if (WebUtils.isIncludeRequest(request)) {
      attributesSnapshot = new HashMap<String, Object>();
      Enumeration<?> attrNames = request.getAttributeNames();
      while (attrNames.hasMoreElements()) {
         String attrName = (String) attrNames.nextElement();
         if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {
            attributesSnapshot.put(attrName, request.getAttribute(attrName));
         }
      }
   }

   // Make framework objects available to handlers and view objects.
   //将框架的一些对象 设置到Request的attribute中,方便后面处理的时候获取
   request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());
   request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);
   request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);
   request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());

   FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);
   if (inputFlashMap != null) {
      request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));
   }
   request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());
   request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);

   try {
      //处理请求调度
      doDispatch(request, response);
   }
   finally {
      if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
         // Restore the original attribute snapshot, in case of an include.
         if (attributesSnapshot != null) {
            restoreAttributesAfterInclude(request, attributesSnapshot);
         }
      }
   }
}
```

**doService的步骤:**

1. 处理属性快照 
2. 将框架的一些对象设置到Request的attribute中
3. 执行 doDispatch方法处理请求 
4. 如果有属性快照,将属性设置到Request中. 

### 对请求进行handler处理



   

 

 



 



















