---
layout: post
title: java应用性能分析
toc: true
cover: /img/cover/why-is-binary.png
tags: ['jvm','java性能优化权威指南']
category: Java
---

# java应用性能分析 

标签（空格分隔）： java性能优化权威指南

---
[TOC]
## 术语 

### 1.通用新能分析分析术语
+ **性能分析器(Profiler)** 将应用程序运行时的行为呈现给用户的一种工具. 
+ **性能文件(profile)** 用于存放性能分析器收集的程序运行的信息
+ **开销(Overhead)**    性能分析器收集性能数据所发费的时间 
+ **调用树(Call Tree)** 以栈的形势构造的的方法列表
+ **过滤器(Filter)** 缩小信息范围的工具. 

### 2.Oracle Solaris Studio Performance Analyzer术语
+ **样本(Experiment)** 使用Performanc Analyzer收集的应用程序的性能数据
+ **collect**  用于收集性能数据的命令行工具 
+ **分析器(Analyzer)** 查看性能数据的图像界面程序
+ **er_print** 用于查看收集到的样本或者样本文件的命令行工具
+ **包含时间(Inclusive time)** 方法自身已经其内部调用其他方法的执行时间总和
+ **独占时间(Exclusive time)** 执行方法时间,不包含调用其他方法的时间开销
+ **归因时间(Attribute time)** 被某方法调用产生的时间开销 
+ **调用-被调用(caller-callee)** 方法直接的关系
+ **系统态CPU时间(System CPU)** 方法运行在内核态所占用的时间或者时间比率
+ **用户态CPU时间(User CPU)** 方法运行在非内核态所占用的时间或者时间比率 

### 3.NetBeans Profiler术语
+ **注入(Instrumentaion)** 在待分析的应用程序的字节码中插入计数器,计时器.
+ **堆(Heap)** JVM使用new关键字分配的对象创建的内存池 
+ **垃圾收集(Garbage Collection)** 从堆上销毁应用程序不在使用的对象的操作
+ **内存泄漏(Memory Leak)** 一个永远不在使用的对象由于一个或者多个java对象对它的引用而不能被垃圾回收
+ **本耗时间(Self Time)** 执行方法的指令所消耗的时间,不包含调用其他方法消耗的时间 
+ **热点(Hot Spot)** 本耗时间较长的方法 
+ **根方法(Root Method)** 选定的进行性能分析的方法.

## Oracle Solaris Studio Performance Analyzer

Performance Analyzer  擅长方法分析,Java monitor对象分析(锁竞争分析)
Performance Analyzer 能够统计消耗在用户态CPU,系统态CPU,锁竞争及其他的事务上的时间,这三项时间是java应用性能分析最关注的三类指标.每一类数据有细分为**包含时间**和**独占时间**.

性能分析步骤:

+ 执行Performance Analyer的`collect`命令,然后运行Java应用,收集新能采样数据.
+ 通过GUI工具或者命令行工具er_print进行性能分析,查看搜集到的性能数据,分析其结果. 

### 支持平台 

只要应用程序的JVM支持**Java虚拟机工具接口(JVM Tool Interface,JVMTI)**,就能对其进行性能分析. 

Performance Analyzer分析本地代码平台依赖: 

+ Solaris SPARC. 
+ Solaris x86/64 
+ Linux  x86/x64.

### 下载/安装Oracle Solaris Studio Performance Analyzer

1.下载地址: `http://download.oracle.com/otn/solaris/studio/OracleDeveloperStudio12.5-linux-x86-rpm.tar.bz2?AuthParam=1500354079_892faf22e150565fa5d4b67251424a20`
2.安装: 

### 抓取性能数据 
收集性能数据的通用步骤: 

+ 将Performance Analyer的bin目录添加到系统的环境变量PATH下
+ 在启动Java应用程序的java命令行前添加 `clloent -j` 启动 
+ 运行Java应用程序用collect命令采集样本数据并生产样本文件.

collect命令行选项 : 
+ `-o <experiment file name>` 指定创建的样本的文件名
+ `-d <experiment directory path>` 指定样本文件存放的目录
+ `-p <option>` 基于采样时间对Java应用进行性能分析,默认时间间隔10毫秒
    +  `-p lo` 将采样时间增大到100毫秒左右
    +  `-p hi` 
    +  `-p <value>` 设置采样时间间隔 value(正整数)
+ `-A <option>` 是否归档目标应用或者JVM使用的对象, 复制到采样文件中.
    + `on` 默认值,这些对象都会归档到样本文件中
    + `off` 不对对象进行归档
    + `copy` 复制,归档对象到样本文件中
+ `-y signal` 根据<signal>控制样本数据采集的力度.  
+ `-h <cpu counter>` 收集cpu计
+ 数器信息并将其余正在执行的应用程序代码进行关联 ,帮组定义发起了代价昂贵操作的方法. 

收集数据： `[root@localhost bin]# collect -j on ./startup.sh ` 

很多时候需要从负荷测试的时候开始收集数据,使用`collect -y` 选项并制定启动或者停止收集数据采样的监听信号. 
启动时: `[root@localhost bin]# collect -j on ./startup.sh -y ./startsh.sh` , 启动后没有开始收集数据,当启动的java进程接收到SIGUSR2信号时开始采集性能数据. 
`ps -ef | grep Xruncollector` ,`ps -aux | grep  Xruncollector ` 　：　获取使用collect命令启动的java应用的进程号

`kill -SIGUSR2 <Java process id>` : 开始收集数据. 再执行这条命令时停止收集数据. 



















