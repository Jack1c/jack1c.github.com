---
layout: post
title: java内存区域与内存溢出
toc: true
cover: /img/cover/why-is-binary.png
tags: ['jvm','深入理解java虚拟机']
category: Java
---

# java内存区域与内存溢出

## 运行时数据区 
JVM执行java程序过程中会将它管理的内存划分若干个不同的数据区域.
java虚拟机运行时数据区域:
![image.png-103.1kB][1]

---
### 程序计数器(Program Conunter Register)
当前线程执行的字节码指示器.记录正在执行的虚拟机字节码指令的地址. 
每条线程都有独立的*程序计数器* 

### Java 虚拟机栈(Java Virtual Machine Stacks)
 虚拟机栈是线程私有的,和线程的生命周期相同.
 每个线程在执行方法时都会同时创建一个栈帧(Stack Frame)用于储存变量表,操作数栈,动态链接,方法出口等信息. 
 方法的调用过程就对应着一个栈帧在虚拟机中入栈到处栈的过程. 
局部变量表中存放了编译期可知的各种数据类型(boolean,byte,char,short,int,float,long,double),对象的应用类型(reference类型)和returnAddress类型(指向一条字节码指令的地址)

> reference类型 : 不能等于对象本身,可能是指向一个指向对象在内存上起始地址的指针,也可能指向一个对象的句柄或者其他与次对象相关的位置. 能通过指向的内容找到对象 .

> long 和 double 类型的长度为64位,数据会占用2两个*局部变量空间(Slot)*,其余的数据类型只占用一个.
> 局部变量表所需的内存空间在编译期间完成分配. 执行一个方法时,方法所需要的局部变量空间是完全确定的,在方法运行期间不会改变大小.

两种异常情况: 

+ 如果线程请求的*栈深度* 大于 虚拟机所允许的深度,抛出StackOverflowError异常
+ 虚拟机栈可以动态扩展时(大部分虚拟机不可以),如果扩展时无法申请到足够的内存.抛出OutOfMemoryError 异常

### 本地方法栈(Native Method Stack)
和**Java虚拟机栈**功能类似,只是执行的方法为本地方法(Native). 
> HotSpot虚拟机直接将**本地方法栈**和**虚拟机栈**合二为一

### Java堆(Java Heap)
Java虚拟机管理中最大的一块区域,多个线程共享,存放对象实例. 
> java虚拟规范 : 所有的对象已经数组都要在堆上分配.Java堆可以处于物理上不连续的内存空间,只要逻辑上连续的即可. 

### 方法区 (Method Area)
多个线程共享的内存区域,存储已经被虚拟机加载的类型信息,常量,静态变量.JIT编译后的代码. 

### 运行时常量池(Runtime Constant Pool)
**方法区**的一部分,用于编译期生成的各种字面常量和符号引用,在类加载后放入**方法区**的**常量池**
运行时常量池具备动态性,在运行期间也可以将新的常量放入常量池.例如`String`类的`intern()`方法. 

### 直接内存区(Deirect Memory)
使用Native函数库直接分配的堆外内存,然后通过一个存储在Java堆的DirectByteBuffer对象作为这块内存的应用. 
> 避免Java堆和Native堆中来回的复制数据

## HotSpot虚拟机对象
### 对象创建
对象的创建过程(不包括Class和数组对象):

+ 虚拟机接收new指令, 检查常量池是否能找到一个类的符号引用, 检查这个符号代表的类是否被加载,解析,初始化,如果没有,执行类加过程.
+ 在类加载后,虚拟机分配内存(内存大小在类加载后已确定).
    + 如果Java堆中内存是绝对规整,使用**指针碰撞**的方法分配内存.
    + 如果Java堆中的内存不是规整的,虚拟机维护一个记录内存可用的列表,在分配的时候从列表中找到一块足够大的空间划分给对象,这种分配方法称为空闲列表(Free List) 
    + 选择分配的方式由Java的堆内存是否规整决定,java堆是否规整由采用的垃圾收集器是否带有压缩整理功能决定.
> 使用Serial,ParNew带Cimpact算法的收集器时,分配内存采用*指针碰撞*
> 使用基于Mark-Sweep算法的CMS收集器时通常方式分配内存的方式是*空闲列表*.
    
   + 解决内存分配时多线程并发的两种方式
        + 1.对分配内存空间的操作进行同步处理(采用CAS分配失败重试的方式保证更新操作的原子性)
        + 2.把内存分配操作安装线程分配在不同的空间中进行,每个线程在Java堆中预先分配一块小的内存,称为**本地线程分配缓冲(Thread Local allocation Buff TLB)**,线程分配内存时指针只在自己的TLAB上分配,只有TLAB用完后从新分配TLAB时才需要锁同步. 虚拟机开启TLAB可以通过 `-XX:+/-UseTLAB` 参数设置. 


+ 内存分配完成后,虚拟机将分配的内存空间初始化为零值.
+ 对对象进行必要的设置,放在**对象头(Object Head)**
    + 类的元数据信息的指针
    + 对象的哈希码
    + 对象的分代年龄信息
+ 执行`<init>`方法,对对象进行初始化(java的初始化).

### 对象的内存布局
在HotSpot虚拟机中,对象在内存中分为3块区域:

+ 对象头(Header),
    + 对象自身运行时数据.例如哈希码(HashCode),GC分代年龄,锁状态标志,线程持有的错,偏向线程ID,偏向时间戳.这个
    + 类型指针,指向他的类元数据的指针.
+ 实例数据(Instance Data),储存程序代中定义的各种类型的字段内容.
+ 对其填充(Padding), 仅仅作为站位符的作用.

> HotSpot VM的自动管理系统要求对象起始地址必须8自己的整数倍,对象的大小必须是8字节的整数倍,当对象的实例数据部分不是8字节的整数时,需要填充.
### 对象的访问定位 
java程序通过栈上的reference数据操作堆内存的具体对象. 

> java虚拟机规范: reference类型在Java虚拟机中只能指向一个对象的引用

通过reference类型访问对象的两种方式:

+ 句柄
在Java堆中划分一块内存作为句柄池,reference中存储句柄池的地址.句柄池中包含了对象的实例数据与类型数据的各自的地址信息.
![image.png-77.8kB][2]
+ 直接指针
![image.png-73.7kB][3]

两种定位方式的优劣: 

+ 使用*句柄*访问的最大好处是reference中储存的是稳定的句柄地址,在对象被移动时只会改变句柄中实例数据指针,reference本身不需要修改. 
+ 使用*直接内存*的最大好处是速度快,因为节省了一次指针定位的时间开销.

> HotSpot 使用的是*直接内存*的方式进行内存访问. 


## OutOfMemoryError异常
### java堆溢出
示例代码：
```java
import java.util.ArrayList;
import java.util.List;
/**
 * VM Args ： -Xms20m  -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
 */
public class HeapOOM {
    static class OOMObject{};
    public static void main(String[] args){
        List<OOMObject> list = new ArrayList<>();
        while (true){
            list.add(new OOMObject());
        }
    }
}
```
运行结果:
```
java.lang.OutOfMemoryError: Java heap space
Dumping heap to java_pid1148.hprof ...
Heap dump file created [28111618 bytes in 0.144 secs]
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
```
分析结果:
![image.png-77.6kB][4]
### 虚拟机栈和本地方法栈溢出
栈容量使用`-Xss`参数设置.

+ 如果线程请求的栈深度大于虚拟机所允许的最大深度,抛出`StackOverflowError`异常
+ 如果虚拟机无法申请足够的内存来扩展栈时,抛出`OutOfMemoryError`异常

实例代码:
```java
/**
 * vm Args : Xss1m
 */
public class Main {
    private static int statcLength = 0;
    public void statckLeak(){
        statcLength++;
        statckLeak();
    }
    public static void main(String[] args) {
        Main main = new Main();
        try {
            main.statckLeak();
        }catch (Throwable throwable){
            System.out.println("最大栈深度为:"+statcLength);
            throwable.printStackTrace();
        }

    }
}
```
运行结果:
```
java.lang.StackOverflowError
最大栈深度为:21673
	at com.company.Main.statckLeak(Main.java:10)
	at com.company.Main.statckLeak(Main.java:10)
	at com.company.Main.statckLeak(Main.java:10)
	at com.company.Main.statckLeak(Main.java:10)
	at com.company.Main.statckLeak(Main.java:10)
```
### 方法区和运行时常量池溢出 
使用 `String.intern()`是一个Native方法,作用是如果字符常量池中存在等于当前字符串则返回字符的String对象,如果不存在则在将此对象的字符串保存到常量池中.
通过 `-XX:PermSize` 和`-XX:MaxPermSize`限制方法区的大小.
Jdk1.8之后: -XX:MetaspaceSize=10M -XX:MaxMetaspaceSize=10M
示例代码:

填充类使永久区内存溢出:
```java
/**
 * VM args -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m
 */
public class JavaMethidAreaOOM {
    static class OOMObject{
    }
    public static void main(String[] args){
        while (true){
            Enhancer enhancer = new Enhancer();
            enhancer.setSuperclass(OOMObject.class);
            enhancer.setUseCache(false);
            enhancer.setCallback(new MethodInterceptor() {
                @Override
                public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                    return methodProxy.invoke(o,objects);
                }
            });
            enhancer.create();
        }
    }
}
```
### 直接内存 溢出
DirectMemory容量可以使用`-XX:MaxDirectMemorySize`指定,如果不指定,则默认和Java堆内存大小相同.

实例代码:
```java
public class DirectMemoryOOM {
    private static final int _1MB = 1024 * 1024;
    public static void main(String[] args) throws IllegalAccessException {
        Field unsafleFiled = Unsafe.class.getDeclaredFields()[0];
        unsafleFiled.setAccessible(true);
        Unsafe unsafe = (Unsafe) unsafleFiled.get(null);
        while (true){
            unsafe.allocateMemory(_1MB * 100);
        }
    }
}
```
运行结果:
```
*** error: can't allocate region
*** set a breakpoint in malloc_error_break to debug
Exception in thread "main" java.lang.OutOfMemoryError
	at sun.misc.Unsafe.allocateMemory(Native Method)
	at com.company.DirectMemoryOOM.main(DirectMemoryOOM.java:17)
```

  [1]: http://static.zybuluo.com/jack4c/ow6jo6xo89p6okxcyff033a8/image.png
  [2]: http://static.zybuluo.com/jack4c/lm63oraaw3q6g1carccvgar9/image.png
  [3]: http://static.zybuluo.com/jack4c/4uhff7gd3jfevvklg2f7syd9/image.png
  [4]: http://static.zybuluo.com/jack4c/ljzhj3sipc80eoxe55t0anv8/image.png