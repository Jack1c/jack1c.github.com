---
layout: post
title: HotSpot VM垃圾收集器
toc: true
cover: /img/cover/why-is-binary.png
tags: ['jvm','java性能优化权威指南']
category: Java
---

# HotSpot VM垃圾收集器

标签（空格分隔）： java性能优化权威指南 JVM概览

---

> java堆中存储的对象由自动内存管理系统(垃圾收集器复制收集),不可被显试销毁

## 分代垃圾收集 
垃圾回收算法基于两个事实 : 

+ 大多数分配对象的存活时间很短 
+ 存活时间久的对象很少引用存活时间段的对象

基于这两个事实HotSpot VM将堆分代 :

### 新生代
新创建的对象会分配到新生代中 
**特点:**

+ 空间比较小
+ 回收比较频繁 
+ 大部分对象存活时间很短 
+ 新生代垃圾收集(Minor GC)关注小冰期有有大量垃圾对象的空间,垃圾收集效率较高

**新生代分为3个独立区域:**

+  Eden *大多数*新对象都分配在这儿(大对象可能只能分配到老年代),在Minor GC后Eden区几乎为空 
+ Survivor(一对) 存放经历过一次Minor GC的对象,

Minor GC :
![image.png-95.3kB][1]
 


### 老年代
长期存活的新生代对象会被提升(Promote)到老年代.

**特点:**

+  占用空间比新生代空间大
+  空间占用的增长速度比新代慢
+  相对于MinorGC老年代收集(主要垃圾收集,完全垃圾收集Full GC)的执行效率低 



### 永久区 
HotSpot VM用永久代存放元数据(类的数据结构,保留的字符串)


> 新生代如何识别存活对象 ?
> 如何识别被老年代引用的新生代对象? 

垃圾收集器不需要扫描整个老年代就能识别新生代的存活关系,HotSpot VM使用
一种称为**卡表(Crad Table)**的数据结构实现. 

**实现过程:** 

+ 将老年代已512字节长度分成若干个块(卡). 
+ 用一个单字节数组和老年代分成的块做映射.这个单字节数组称为**卡表**
+ 如果老年代对象的字段引用新生代对象,HotSpot VM将卡表中与该字段对应的值改变(将卡标记为脏卡).
+ 在Minor GC时垃圾收集器通过卡表中的脏卡映射关系查找老年代中引用新生代的字段,从而找到新生代的存活对象. 

**卡表数据结构的维护:** 
通过HotSpot VM的字节码解释器和JIT编译器使用**写屏障(Write Barrier)**来维护
写屏障:一段将卡状态设置成为脏的代码.

+ 解释器每次执行更新引用的字节码时都会执行*写屏障* 
+ JIT编译器在生成更新引用的代码后,会生成一段*写屏障*代码

###分代垃圾收集优点:
每个分代都可以依据其特点使用最适当的垃圾回收算法 

+ 新生代通常使用速度快的垃圾回收算法的收集器.
+ 老年代通常使用空间效率高的垃圾回收器.

## 快速内存分配
> 对象内存分配器在重用堆空间之前需要找到可以满足其分配需求的空闲空间

垃圾收集器回收新生代的内存方式为复制,回收后Eden区总是为空.
在Eden中使用**指针碰撞(Bump-the-Pointer)**的技术分配空间. 

### 指针碰撞: 
追踪最后一个分配的对象(top),当有新的分配请求时,分配器只需检查top和
Eden末端之前的空间十分能容纳.如果能容纳top跳到最新分配对象的末端.

多线程时处理
大多数java的应用是多线程的,在分配内存时必须考虑线程安全. 
如果对在Eden中分配的操作加全局锁,就会降低性能,所有HotSpot没有采用这种方式,而是使用**线程本地分配缓存区(Thread-Local Allocation Buffer TLAB)**的技术.

*线程本地分配缓存区:*
为每个线程设置各种的缓存区(Eden的一小块)来改善多线程分配的吞吐量. 
这块区域只有一个线程从中分配空间,所以使用*指针碰撞*分配内存时不需任何锁.
当线程的TLAB填满时需要获取新的空间操作就需要采用多线程安全的方式.

## 垃圾收集器
> JVM没有假定具体的自动内存管理系统,虚拟的实现应根据系统的需求选择内存管理技术.

### Serial收集器
老年代使用*标记-压缩*拦截收集器. 
Minor GC 和 Full GC都是以Stop-The-World(收集时停止应用程序)方式,只有等垃圾收集结束后应用程序才会执行.
**标记-压缩收集器:** 
先找出老年代中有哪些存活的对象,将他们置于堆的头部,将堆尾部的空间空闲出来.
Serial收集器适用于大多数对停顿时间要求不要和客户端运行的应用. 

### Parallel收集器吞吐量优先  
新生代: Stop-The-World方式
老年代: 标记-压缩方式
Minor GC和Full GC 都是并行的. 
### Mostly-Concurrent收集器:低延迟优先
在Stop-The-World模式中应用线程在垃圾收集开始时停止响应.知道垃圾收集结束才继续处理外部请求. 
许多应用响应速度比端到端的吞吐量更为总要,为了应对这种情况HotSpot VM引入Mostly-Concurrent收集器(并发标记收集器,CMS收集器).它管理新生代的方式与Parallel收集器相同.而在老年代则尽可能的并发执行,每个垃圾回收周期只有2次停顿.

CMS收集器: 

+ 初始化标记 : 短暂停顿,标记从GC Roots可达的老年代对象
+ 并发标记   : 标记所有这些老年对象可达的老年代对象 
+ 重新标记   : 再次停顿,重新遍历所有在*并发标记* 期间有变动的对象进行标记 
+ 预清除(Pre-Cleaning) : 在*并发标记*之后,在重新标记之前.重新遍历那些在标记期间因并发而被改掉的对象. 
+ 并发清除(Concurrent Sweeping) : 清除整个java堆,释放没有迁移的垃圾对象.



### Garbage-First收集器:替换CMS
并行和增量式压缩低停顿收集器. 
使用G1时和其他收集器在堆



  [1]: http://static.zybuluo.com/jack4c/90tuq9belz86em6elk4y60ze/image.png