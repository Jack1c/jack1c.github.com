---
layout: post
title: CPU使用率过高
toc: true
cover: /img/cover/9ee6c1c5d88b0468af1a3280865a6b7a.png
tags: ['linux']
category: Linux
---

## cpu使用率

通常使用linux自带的工具`top,ps`来查看CPU的使用率

### 什么是CPU的使用率?

linux系统是一个多任务系统, 系统将CPU划分成很短的时间片,通过调度器分配给各个任务使用,造成多任务运行的错觉. 

为了维护CPU的时间片, Linux系统事前定义了节拍率,在内核中使用HZ表示, 使用全局变量Jiffies来记录开机以来的节拍率. 每发生一次中断, 值加一. 

CPU使用率,除了空闲时间外其他时间占总CPU的时间百分比, 用公式表示:

![img](../../image/Linux/CPU使用率公式1.png)

事实上为了计算CPU使用率. 性能工具一般都会隔一段时间取两个值,做差后计算这段时间的平均CPU使用率:



![img](../../image/Linux/CPU使用率公式2.png)

如何查看CPU的使用率?

+ top 显示了总体CPU和内存的使用情况. 已经各个进程的资源的使用情况
+ ps则只显示了每个进程的资源使用情况

top的输出:

```
top - 15:28:47 up 32 min,  2 users,  load average: 0.00, 0.01, 0.02
Tasks: 115 total,   1 running, 114 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  7992344 total,  7655884 free,   152312 used,   184148 buff/cache
KiB Swap:  4063228 total,  4063228 free,        0 used.  7584852 avail Mem 

   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND   
  1599 root      20   0  161952   2208   1556 R   0.3  0.0   0:00.02 top       
     1 root      20   0  128008   6572   4152 S   0.0  0.1   0:01.53 systemd   
     2 root      20   0       0      0      0 S   0.0  0.0   0:00.01 kthreadd  
     3 root      20   0       0      0      0 S   0.0  0.0   0:00.04 ksoftirqd+
     5 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0+
     6 root      20   0       0      0      0 S   0.0  0.0   0:00.05 kworker/u+
     7 root      rt   0       0      0      0 S   0.0  0.0   0:00.00 migration+
     8 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcu_bh    
     9 root      20   0       0      0      0 S   0.0  0.0   0:00.26 rcu_sched 
    10 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 lru-add-d+
    11 root      rt   0       0      0      0 S   0.0  0.0   0:00.00 watchdog/0
    12 root      rt   0       0      0      0 S   0.0  0.0   0:00.00 watchdog/1
    13 root      rt   0       0      0      0 S   0.0  0.0   0:00.02 migration+
    14 root      20   0       0      0      0 S   0.0  0.0   0:00.01 ksoftirqd+
    16 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/1+
    18 root      20   0       0      0      0 S   0.0  0.0   0:00.00 kdevtmpfs 
    19 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 netns  
```

第三行为CPU的使用率的输出:

+ user (缩写为us) 代表用户态CPU时间, 不包含nice时间,但是包含guest的时间
+ system(缩写为sys) 代表内核态CPU时间

+ nice(缩写为ni) 代表低优先级用户态CPU时间,
+ idle(缩写为id) 代表空闲时间.  不包括I/O的时间
+ iowait(缩写为wa) 代表等待I/O的CPU时间
+ irq(缩写为hi) 代表处理硬中断的时间 
+ softtirq(缩写为si) 代表处理软中断的CPU时间
+ steal(缩写为st) 代表当系统运行在虚拟机中的时候,被其他虚拟机中的CPU时间.

按数字1 可以切到每个CPU的使用率. 

```
top - 15:42:45 up 46 min,  2 users,  load average: 0.00, 0.01, 0.02
Tasks: 115 total,   1 running, 114 sleeping,   0 stopped,   0 zombie
%Cpu0  :  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu1  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
```

每个进程都一个%CPU的列, 代表进程CPU的使用率, 打算用户态和内核态CPU使用率的总和:

+ 包括进程的用户空间使用的CPU

+ 通过系统调用的内核CPU
+ 就绪队列运行CPU
+ 在虚拟环境下,还包含虚拟机占用的CPU 



在top的输出结果中没有细分进程的用户态CPU和内核态CPU, 如果想要查看进程的详情情况,使用pidstat

使用`pidstat`每间隔1秒暂时进程的5组CPU使用率:

```
[root@localhost ~]# pidstat 1 5
Linux 3.10.0-862.el7.x86_64 (localhost.localdomain) 	06/15/2019 	_x86_64_	(2 CPU)

05:27:30 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command

05:27:31 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command

05:27:32 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command
05:27:33 PM     0      2585    0.99    0.00    0.00    0.99     0  pidstat

05:27:33 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command
05:27:34 PM     0      2585    0.00    1.00    0.00    1.00     0  pidstat

05:27:34 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command

Average:      UID       PID    %usr %system  %guest    %CPU   CPU  Command
Average:        0      2585    0.20    0.20    0.00    0.40     -  pidstat
```

+ %usr 用户态CPU使用率
+ %system 内核态CPU使用率
+ %guest 运行虚拟机CPU使用率 
+ %wait 等待CPU使用率
+ %CPU 总的CPU使用率 

最后Average部分,计算了5组数据的平均值





















   

 