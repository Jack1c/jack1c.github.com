---
layout: post
title: CPU上下文切换
toc: true
cover: /img/cover/9ee6c1c5d88b0468af1a3280865a6b7a.png
tags: ['linux']
category: Linux
---

# CPU上下文切换 ?

多个进程竞争CPU可以导致平均负载(Load Average) 升高, 竞争CPU的时候没有真正的运行,在竞争过程发生的**CPU上下文切换**导致的. 



### 为什么会存在CPU上下文切换 ?

Linux系统为多任务系统, 但是CPU在执行任务时,某个时刻只能执行一个任务. 所以操作系统将CPU轮流执行多个任务,执行的任务在CPU快速的切换造成同时执行多个任务的假象. 在切换任务后,执行任务前,CPU需要知道执行任务的从哪里加载, 从哪里开始运行, 所以需要 系统提前设置好**CPU寄存器和程序计数器(Program Counter, PC)** 



+ CPU寄存器: CPU内置的小容量但是速度极快的内存
+ 程序计数器 : 用来存储CPU正在执行的CPU指令的位置, 或者下一条指令的位置. 

它们是CPU执行任务的必须的依赖环境, 叫做**CPU的上下文**. 







![CPU上下文切换](../../image/Linux/image-20181202122328329.png)



## 什么是CPU上下文切换

把前一个任务的CPU上下文保存起来,然后加载下一个任务的上下文. 保存下的CPU上下文会存储在内核中, 并在任务从新被执行时再次加载.  

根据任务的不同 CPU上下文切换可以分为: 

+ 进程上下文切换
+ 线程上下文切换
+ 中断上下文切换

## 进程上下文切换

### 进程内的CPU上下文切换

Linux系统根据特权等级把进程的运行空间分为内核空间

![进程执行空间](../../image/Linux/进程执行空间.png)

+ 内核空间(Ring0) 具有最高权限, 可以访问任何资源
+ 用户空间(Ring3) 只能访问受限资源. 只有通过**系统调用**来访问特权资源. 



进程既可以在用户空间运行,也可以在内核空间运行. 进程通过**系统调用**来从用户空间到内核空间. 例如 读取文件 .系统调用过程会发生CPU上下文切换,执行流程

1. 保存CPU寄存器中用户态的指令位置,
2. 将CPU寄存器更新为需要执行的内核态的指令的位置
3. 跳转到内核态运行内核任务 

在系统调用结束后, CPU寄存器需要恢复到原来保存用户态的位置, 然后切换到用户空间,继续执行进程.  所以一次系统调用发生了两次CPU上下文切换. 

### 进程间的上下文切换

进程是由内核来管理和调度的, 所以进程的切换只能发生在内核态, 进程的上下文不仅包含虚拟内存, 全局变量, 等用户空间资源, 还包含内核堆栈,寄存器等内存空间的状态. 

因此, 在进程的上下文切换时比系统调用还多了一步: 保存当前进程的内核状态和CPU寄存器之前,先把进程的虚拟内存,栈等保存下来, 在加载了下一进程的内核态后 还需要刷新进程的虚拟内存和用户栈 .

如下图所示:

![CPU进程上下文切换](../../image/Linux/CPU进程上下文切换.png)



保存和恢复上下文的过程需要在内核CPU上运行才能完成,每次上下文切换需要几十纳秒到到数微秒的CPU时间. 在进程上下文切换次数较多时 容易导致CPU将大量的时间耗费在寄存器,内核栈,以及虚拟内存等资源的保存和恢复上. 

Linux系统是通过**TLB(Translation Lookaside Buffer)** 来管理虚拟内存到屋里内存的映射关系. 当虚拟内存更新后TLB也需要刷新, 导致内存访问变慢. 在多CPU系统上 缓存是多个处理器共享的, 刷新缓存不仅会影响当前处理器的进程, 还会影响共享缓存的其他的处理的进程. 

**什么时候会进行进程上下文切换?**

Linux系统为每个CPU都维护了一个**就绪队列**,  将活跃的进程(处于正在运行和等待CPU的进程) 安装优先级和等待CPU的时间排序, 然后选择最需要CPU的进程(优先级最高和等待CPU时间最长的进程)来运行.  

> 为了保证所有的进程得到公平的调度, CPU时间将划分为一段段的时间片. 这些时间片,在轮流分配给各个进程. 

 **进程什么时候会被调度到CPU上运行?**

1. 当某个进程的CPU的时间片耗尽了,就会被系统挂起,切换到其他正在等待CPU的进程运行 
2. 当进程的系统资源不足(例如内存不足)时, 需要等到资源满足后才能运行, 这个时候进程会被挂起, 并由系统调度气筒进程运行. 
3. 将进程调用`sleep`函数将自己主动挂起时. 
4. 当有优先级更高的优先级程序运行时, 为了保证高优先级进程运行, 当前进程回会被挂起, 运行高优先级进程. 
5. 发生硬件中断是, CPU上的进程会被挂起,先执行内核的中断服务程序. 

## 线程上下文切换

线程和进程的区别: 

+ **线程是调度的基本单位**

+ **进程是资源拥有的基本单位**

内存中的任务调度,调度的对象是线程, 进程只是给线程提供虚拟内存, 全局变量等资源. 

线程的上下文切换的两种情况:

1. 前后两个线程, 属于不同进程.  因此资源不共享, 所有切换过程和进程上下文切换相同
2. 前后两个线程属于同一个进程, 此时 虚拟机内存是共享的, 所以在切换时, 虚拟内存资源保持, 只需要切换线程的私有数据, 寄存器,等不共享的数据. 

进程内的线程的上下文切换比进程间的切换消耗更少的资源, 这是多线程代替多进程的一个优势. 

## 中断上下文切换

为了响应硬件的事件, 中断处理会打断当前进程的正常调度和执行, 转而调用中断处理程序, 响应设备事件.  

而打断其他的进程时, 就需要将进程的状态保存下来, 中断结束后进程仍然可以从原来的状态恢复运行.

 

和进程上下文切换不同的的是中断上下文切换不涉及进程的用户态, 所以中断过程打断了一个正处于用户态的进程, 也不需要保存和恢复这个进程的虚拟内存. 全局变量等用户资源. 中断上下文 只包含内核态服务程序执行所需要的必须的状态, 包括CPU寄存器. 内核堆栈, 硬件中断参数等.



**对应CPU 中断处理比进程执行拥有更高的优先级**, 所有中断上下文切换不会与进程上下文切换同时发生.  中断会打断正常执行的进程, 所以大部分中断程序都短小精悍, 以便尽可能快的执行结束. 

中断的上下文切换也需要消耗CPU, 切换次数过多也会消耗大量的CPU. 





---

## 怎样查看上下文切换情况



### 使用vmstat查看系统进程上下文切换情况

vmstat是一个常用的性能分析工具, 主要用来分析**系统的内存使用情况**,也常用来分析CPU上下文切换和中断次数. 



```
# 每隔5秒输出一组数据
~# vmstat 5
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----

 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st

 0  0      0 6306876  73684 801032    0    0   227     5   51   94  1  0 99  0  0
 
```

需要特别关注的四列内容:

+ cs(context switch) 每秒上下文切换次数
+ in(interrupt) 每秒中断次数
+ r(Running or Rannale) 就绪队列的长度,(正在运行和等待CPU的进程数)
+ b(Blocked) 处于不可中断睡眠状态的进程数

### 使用pidstat查看进程的上下文切换情况

vmstat只能给出系统的上下文切换情况, 如果需要查看每个进程的上下文切换情况,需要使用pidstat. 

加上w选项就可以查看每个进程的上下文切换情况.



```
$ pidstat -w 5
Linux 4.15.0-47-generic (jack-pc) 	2019年04月11日 	_x86_64_	(12 CPU)

23时28分16秒   UID       PID   cswch/s nvcswch/s  Command
23时28分21秒     0         8      5.59      0.00  rcu_sched
23时28分21秒     0        11      0.20      0.00  watchdog/0
23时28分21秒     0        14      0.20      0.00  watchdog/1
...

```

+ cswch

    每秒自愿上下文切换(voluntary context switch)的次数

    指进程**无法获取资源**导致的上下文切换. 例如, I/O, 内存等资源不足就会发生上下文切换. 



+ nvcswch

    每秒非自愿上下文切换(non voluntary context switch)的次数 

    只进程由于**时间片耗完**导致被系统强制调度,进而发生的上下切换. 比如有大量的进程都在争抢CPU时, 就会发生非自愿上下文切换.  



### 使用Sysbench模拟多线程调度,查看上下文切换情况

在空闲时使用vmstata查看一系统的上下文切换次数

```
$ vmstat 1 1
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0      0 3757404 310244 2924480    0    0     0     1    6    6  0  0 100  0  0
```



1. 在第一个终端模拟多线程调度瓶颈

    ```shell
    sysbench --threads=10 --max-time=300 threads run 
    
    ```

2. 在第二个终端运行vmstat 观察上下文切换情况

